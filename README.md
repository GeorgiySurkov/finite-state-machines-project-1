# Реализация конечного автомата для регулярного языка

Автор: Сурков Георгий  
Группа: 21.Б11-пу

## Задание:

1. Разработать распознающий КА для цепочек определенного в задании регулярного языка над заданным алфавитом и
   реализовать его в виде подпрограммы.

2. Разработать программу поиска цепочек этого языка в последовательности символов, используя подпрограмму пункта.   
   **Вход:** последовательность символов алфавита регулярного языка задания  
   **Выход:** последовательность строк формата "`номер`: `цепочка`", где  
   `номер` – номер позиции начала цепочки языка в последовательности символов.  
   `цепочка` – найденная цепочка языка в последовательности символов.  
   Если цепочек языка не найдено, то на выходе отображается «цепочек не найдено»

## Регулярный язык:

Строка символов -,a,b,+, начинающаяся с префикса + и заканчивающаяся суффиксом +, между которыми располагается
последовательность символов a,b  (она может быть и пустой), в которой любая пара одинаковых символов разделяется
символом - (пример: +a-a-ab-b-bab-b+).

## ДКА

### Диаграмма переходов

![Диаграмма переходов](https://github.com/GeorgiySurkov/finite-state-machines-project-1/raw/master/state-machine.png)

### Таблица переходов

| Состояние | +   | -   | a   | b   |
|-----------|-----|-----|-----|-----|
| -> q0     | q1  | ∅   | ∅   | ∅   |
| q1        | q6  | ∅   | q2  | q4  |
| q2        | q6  | q3  | ∅   | ∅   |
| q3        | ∅   | ∅   | q2  | ∅   |
| q4        | q6  | q5  | q2  | ∅   |
| q5        | ∅   | ∅   | ∅   | q4  |
| q6*       | ∅   | ∅   | ∅   | ∅   |
| ∅         | ∅   | ∅   | ∅   | ∅   |

## Регулярное выражение, задающее язык

Символы алфавита: +, –, a, b (+ в кавычках - символ)

```
"+"(ε+b(-b)*)((a(-a)*)(b(-b)*))*(ε+(a(-a)*))"+"
```

## Листинг программы

Файл `simple_find.py`:

```python
from typing import Iterator

Command = dict[str, int]
Program = list[Command]


def match(text: str) -> int:
    final_state = 6  # состояние, которое обозначает распознанный регулярный язык

    # program кодирует таблицу переходов конечного автомата.
    # Индекс в массиве обозначает состояние.
    # Словарь по индексу означает переход в следующее состояние
    # в зависимости от текущего символа.
    program: Program = [
        {"+": 1},
        {"+": 6, "a": 2, "b": 4},
        {"+": 6, "-": 3, "b": 4},
        {"a": 2},
        {"+": 6, "-": 5, "a": 2},
        {"b": 4},
    ]

    state = 0
    for i, ch in enumerate(text):
        possible_next_state = program[state].get(ch)
        if possible_next_state == final_state:
            return i + 1  # Конечный автомат распознал регулярный язык
        elif possible_next_state is None:
            return -1  # Конечный автомат не распознал регулярный язык
        else:
            state = possible_next_state
    return -1


def find_all_patterns(text: str) -> Iterator[tuple[int, int]]:
    for i in range(len(text)):
        end = match(text[i:])
        if end != -1:
            yield i, i + end


def main():
    text = input()
    no_patterns = True
    for begin, end in find_all_patterns(text):
        output = "{}: {}".format(begin + 1, text[begin:end])
        print(output)
        no_patterns = False
    if no_patterns:
        print("Цепочек не найдено")


if __name__ == '__main__':
    main()

```

Файл `test_simple_find.py`:

```python
import re

import pytest
from hypothesis import given
from hypothesis.strategies import from_regex

from simple_find import match, find_all_patterns

re_matcher = re.compile(r"^\+(|(b(-b)*))((a(-a)*)(b(-b)*))*(|(a(-a)*))\+$")


@given(from_regex(re_matcher, fullmatch=True))
def test_match_with_equivalent_regex(text):
    assert match(text) == len(text)


@pytest.mark.parametrize("text, expected", [
    ("", -1),
    ("a", -1),
    ("b", -1),
    ("+", -1),
    ("-", -1),
    ("ab", -1),
    ("ba", -1),
    ("++", 2),
    ("+a+", 3),
    ("+b+", 3),
    ("+ab+", 4),
    ("+ba+", 4),
    ("+a+b+", 3),
    ("+b+a+", 3),
    ("+a-a+", 5),
    ("+b-b+", 5),
    ("+a-b+", -1),
    ("+b-a+", -1),
    ("+a+a+", 3),
    ("+b+b+", 3),
    ("+ab-b+", 6),
    ("+ba-a+", 6),
    ("+ab-a+", -1),
    ("+ba-b+", -1),
    ("+ab-ba+", 7),
    ("sjknvsdv", -1),  # случайный текст
])
def test_match(text, expected):
    assert match(text) == expected


@pytest.mark.parametrize("text, expected_patterns", [
    ("", []),
    ("a", []),
    ("b", []),
    ("+", []),
    ("-", []),
    ("ab", []),
    ("ba", []),
    ("++", ["++"]),
    ("+a+a+", ["+a+", "+a+"]),
    ("+b+b+", ["+b+", "+b+"]),
    ("+++", ["++", "++"]),
    ("++a++", ["++", "+a+", "++"]),
    ("+ab-ba++ba+", ["+ab-ba+", "++", "+ba+"]),
    ("+ab-b+++aba+bab++", ["+ab-b+", "++", "++", "+aba+", "+bab+", "++"]),
])
def test_find_all_patterns(text, expected_patterns):
    result_patterns = list(text[begin:end] for begin, end in find_all_patterns(text))
    assert result_patterns == expected_patterns

```

## Краткое описание работы программы

Функция `match` принимает на вход строку и возвращает индекс последнего символа, который распознан конечным автоматом.
Если конечный автомат не распознал регулярный язык, то возвращается `-1`.  
Принцип работы:

1. Далее подпрограмма осуществляет изменение своего состояния согласно с таблицей перехода, пока не встретит неизвестный
   символ или не перейдет в дьявольское состояние (и тут же вернет -1) или не дойдет до конца строки.
2. Если конечный автомат остановился в финальном состоянии, то возвращается индекс последнего символа, который распознан
   конечным автоматом. Иначе возвращается `-1`.

Функция `find_all_patterns` принимает на вход строку и возвращает генератор, который возвращает кортежи из двух
элементов: индекс начала и конца регулярного языка.

## Таблица тестирования программы

| Номер теста | Входные данные     | Результат                                                           |
|-------------|:-------------------|:--------------------------------------------------------------------|
| 1           |                    | Цепочек не найдено                                                  |
| 2           | a                  | Цепочек не найдено                                                  |
| 3           | b                  | Цепочек не найдено                                                  |
| 4           | +                  | Цепочек не найдено                                                  |
| 5           | -                  | Цепочек не найдено                                                  |
| 6           | ab                 | Цепочек не найдено                                                  |
| 7           | ba                 | Цепочек не найдено                                                  |
| 8           | ++                 | 1: ++<br/>                                                          |
| 9           | +a+a+              | 1: +a+<br/>3: +a+<br/>                                              |
| 10          | +b+b+              | 1: +b+<br/>3: +b+<br/>                                              |
| 11          | +++                | 1: ++<br/>2: ++<br/>                                                |
| 12          | ++a++              | 1: ++<br/>2: +a+<br/>4: ++<br/>                                     |
| 13          | +ab-ba++ba+        | 1: +ab-ba+<br/>7: ++<br/>8: +ba+<br/>                               |
| 14          | +ab-b+++aba+bab++  | 1: +ab-b+<br/>6: ++<br/>7: ++<br/>8: +aba+<br/>12: +bab+<br/>16: ++ |
| 15          | ajfdbndrbodmbfld;b | Цепочек не найдено                                                  |
